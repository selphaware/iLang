# 🧩 iLang Cross-Language ABI Generation — Cases 1 & 2

## 📘 Overview

This document explains how iLang handles code generation and compilation for both AI‑generated code and user‑written code.
In both cases, Python acts as the **orchestrator**, ensuring everything compiles down to a common **C ABI interface**.

---

## 🧩 Case 1 — AI‑Generated Code → C ABI

> The user calls:
> ```python
> x = C("Write a C function that ...")
> ```

### 🔁 Flow

```
prompt  ───▶  GPT‑5
              ↓
        (Generated source code)
              ↓
        codegen.py writes:
        ├─ module.c
        ├─ module.h
        ├─ module.abi.json
              ↓
        system compiler
        └─ module.o / libmodule.a / libmodule.so
```

### ✅ Output Artifacts

| File | Purpose |
|------|----------|
| `.c` | Function implementation(s) generated by GPT |
| `.h` | Header exposing ABI declarations |
| `.abi.json` | Manifest with symbols, argument types, and metadata |
| `.o` / `.a` / `.so` | Compiled binary implementing the ABI |

Python orchestrates everything:
1. Calls GPT‑5 through `aiinterface.chat()`
2. Writes the `.c`, `.h`, and `.abi.json` files
3. Runs `gcc` (or `clang`) via `subprocess`
4. Registers the resulting ABI object (`x`) inside iLang for linkage.

---

## 🧩 Case 2 — User‑Written Code → C ABI

> The user writes multi‑language blocks inside iLang:
> ```ilang
> begin lang: x, py;
>     (some Python code)
> end lang;
>
> begin lang: x, rust;
>     (some Rust code)
> end lang;
> ```

### 🔁 Flow

```
Python / Rust / JS source  ───▶  iLang compiler
                             ↓
                    (transpiles or compiles)
                             ↓
                common output structure:
                ├─ module.c   (or wrapper.c)
                ├─ module.h
                ├─ module.abi.json
                └─ libmodule.a / .so / .o
```

### ✅ What “convert to C” really means

| Language | How to reach a C ABI | Notes |
|-----------|---------------------|-------|
| **Rust** | `#[no_mangle] extern "C"` + `cdylib` / `staticlib` | Generates `.h` + `.a/.so` automatically |
| **Python** | `Cython` / `mypyc` / `m2cgen` / `ONNX export` | Creates C or C‑callable shared object |
| **C++** | `extern "C"` wrapper | Compiles directly to `.o/.a/.so` |
| **JavaScript** | WebAssembly (WASI) / Emscripten + C interface | Optional route |
| **Others** | Must emit an `extern "C"` entry layer | Standardized ABI |

---

## 🧠 Key Insight

No matter how the code is written (AI‑generated or user‑written),
the **output target** is always:

```
<H> + <O> + <ABI manifest>
```

This trio *is* the ABI module in iLang.

That means:
- Any language → compiled to a **C ABI boundary**
- All modules communicate through the same contract
- The `.F → .X → .I` pipeline remains consistent and composable

---

## 🧭 Summary Table

| Case | Source | Who creates .C/.H/.ABI | Compilation | Result |
|------|---------|------------------------|--------------|---------|
| **1** | Prompt → GPT | GPT + `codegen.py` | `gcc` / `clang` | Machine‑generated C ABI module |
| **2** | User code (Python/Rust/JS) | iLang compiler (transpiler + ABI wrapper) | language‑specific compiler | Same C ABI module |

---

## 🧩 Final Takeaway

| Component | Role |
|------------|------|
| **.C file** | Function implementation |
| **.H file** | ABI declaration |
| **.ABI manifest** | JSON metadata (symbols, versioning, memory policy) |
| **.O / .A / .SO** | Compiled object or library implementing the ABI |

Thus, regardless of origin — AI synthesis or manual coding — iLang standardizes every module as a **C ABI‑compliant unit**, making them language‑agnostic and linkable at the integration layer.
